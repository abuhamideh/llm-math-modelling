{
    "parametrized_description": "A sand company delivers sand using small containers and large containers. Each small container requires UnloadPersonsSmall persons to unload and can hold CapacitySmall units of sand. Each large container requires UnloadPersonsLarge persons to unload and can hold CapacityLarge units of sand. The number of small containers used must be RatioSmallToLargeContainers times the number of large containers used. At least MinSmallContainers small containers and MinLargeContainers large containers must be used. The company has TotalPersonsAvailable persons available. The objective is to maximize the total units of sand delivered.",
    "keywords": [
        "N.A."
    ],
    "parameters": {
        "UnloadPersonsSmall": {
            "description": "Number of persons required to unload a small container",
            "shape": []
        },
        "CapacitySmall": {
            "description": "Units of sand a small container can hold",
            "shape": []
        },
        "UnloadPersonsLarge": {
            "description": "Number of persons required to unload a large container",
            "shape": []
        },
        "CapacityLarge": {
            "description": "Units of sand a large container can hold",
            "shape": []
        },
        "RatioSmallToLargeContainers": {
            "description": "Required ratio of small containers to large containers",
            "shape": []
        },
        "MinSmallContainers": {
            "description": "Minimum number of small containers to be used",
            "shape": []
        },
        "MinLargeContainers": {
            "description": "Minimum number of large containers to be used",
            "shape": []
        },
        "TotalPersonsAvailable": {
            "description": "Total number of persons available",
            "shape": []
        }
    },
    "variables": {
        "SmallContainers": {
            "description": "The number of small containers used",
            "type": "continuous",
            "shape": [
                "Integer"
            ]
        },
        "LargeContainers": {
            "description": "The number of large containers used",
            "type": "continuous",
            "shape": [
                "Integer"
            ]
        }
    },
    "constraints": [
        {
            "description": "The number of small containers used must be RatioSmallToLargeContainers times the number of large containers used.",
            "formulation": "SmallContainers = RatioSmallToLargeContainers \\times LargeContainers",
            "code": {
                "gurobipy": "model.addConstr(SmallContainers == RatioSmallToLargeContainers * LargeContainers)"
            }
        },
        {
            "description": "At least MinSmallContainers small containers must be used.",
            "formulation": "SmallContainers \\geq MinSmallContainers",
            "code": {
                "gurobipy": "model.addConstr(SmallContainers >= MinSmallContainers)"
            }
        },
        {
            "description": "At least MinLargeContainers large containers must be used.",
            "formulation": "LargeContainers \\geq MinLargeContainers",
            "code": {
                "gurobipy": "model.addConstr(LargeContainers >= MinLargeContainers)"
            }
        },
        {
            "description": "The total number of persons required to unload all containers cannot exceed TotalPersonsAvailable.",
            "formulation": "UnloadPersonsSmall \\\\cdot SmallContainers + UnloadPersonsLarge \\\\cdot LargeContainers \\\\leq TotalPersonsAvailable",
            "code": {
                "gurobipy": "model.addConstr(UnloadPersonsSmall * SmallContainers + UnloadPersonsLarge * LargeContainers <= TotalPersonsAvailable)"
            }
        }
    ],
    "objective": {
        "description": "Total units of sand delivered is the sum of the sand held by small and large containers. The objective is to maximize the total units of sand delivered.",
        "formulation": "Max \\left( SmallContainers \\times CapacitySmall + LargeContainers \\times CapacityLarge \\right )",
        "code": {
            "gurobipy": "model.setObjective(SmallContainers * CapacitySmall + LargeContainers * CapacityLarge, GRB.MAXIMIZE)"
        }
    }
}